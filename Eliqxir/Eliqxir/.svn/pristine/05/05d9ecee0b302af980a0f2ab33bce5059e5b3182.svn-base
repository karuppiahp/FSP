package com.eliqxir.vendor;

import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.http.NameValuePair;
import org.apache.http.message.BasicNameValuePair;
import org.json.JSONException;
import org.json.JSONObject;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.os.AsyncTask;
import android.os.Bundle;
import android.text.Editable;
import android.text.InputFilter;
import android.text.Spanned;
import android.text.TextWatcher;
import android.util.Log;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

import com.eliqxir.R;
import com.eliqxir.adapter.SpinnerAdapter;
import com.eliqxir.support.ServerResponse;
import com.eliqxir.support.ServerResponse.RequestType;
import com.eliqxir.tabhostfragments.TabsFragmentActivity;
import com.eliqxir.utils.Constant;
import com.eliqxir.utils.UrlGenerator;
import com.eliqxir.utils.Utils;

public class AddItemActivity extends Activity implements OnClickListener {
	public void onStop()
	{
		if(Constant.isVendorAvailable.equals("notAvailable"))
		{
			finish();
		}
		super.onStop();
		
	}
	ImageButton backImg, cartBtn, btnSlideMenu, btnForAddItem, btnForScan;
	TextView textForHeader;
	int itemStatus;
	CheckBox availableBtn, FeaturedBtn;
	boolean available = true, featured = true;
	EditText editTxtForName, editTxtForQty, editTxtForFiOz, editTxtForPrice,
			editTextForAddItemWeight, editTextForAddItemSku,
			editTextForAddItemDesc, editTextForAddItemShortDesc,
			editTextForAddItemMetaDesc;
	Spinner spinnerForCategory, spinnerForSubCategory;
	ArrayList<String> categoryList = new ArrayList<String>();
	ArrayList<String> subCategoryList = new ArrayList<String>();
	ArrayList<String> subCategoryIdList = new ArrayList<String>();
	HashMap<String, String> selectedHasmap = new HashMap<String, String>();
	String selectedCategory = "", selectedsubCategory = "",
			selectedsubCategoryId = "", selectedPrice;
	private String current = "";

	public boolean onKeyDown(int keyCode, KeyEvent event) {
		if (keyCode == KeyEvent.KEYCODE_BACK) {
			startActivity(new Intent(AddItemActivity.this,
					TabsFragmentActivity.class));
		}

		return false;
	}



	@SuppressWarnings("rawtypes")
	@Override
	public void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setContentView(R.layout.add_item);
		categoryList.clear();
		btnSlideMenu = (ImageButton) findViewById(R.id.btnSliderMenu);
		backImg = (ImageButton) findViewById(R.id.backBtn);
		cartBtn = (ImageButton) findViewById(R.id.cartBtn);
		textForHeader = (TextView) findViewById(R.id.textForHeader);
		availableBtn = (CheckBox) findViewById(R.id.imageForAddAvailable);
		FeaturedBtn = (CheckBox) findViewById(R.id.imageForAddFeatured);
		btnForAddItem = (ImageButton) findViewById(R.id.btnForAddItem);
		editTxtForName = (EditText) findViewById(R.id.editTextForAddItemName);
		editTxtForQty = (EditText) findViewById(R.id.editTextForAddItemQty);
		editTxtForFiOz = (EditText) findViewById(R.id.editTextForAddItemFiOz);
		editTxtForPrice = (EditText) findViewById(R.id.editTextForAddItemPrice);
		spinnerForCategory = (Spinner) findViewById(R.id.editTextForAddItemCategory);
		spinnerForSubCategory = (Spinner) findViewById(R.id.editTextForAddItemSubCategory);
		editTextForAddItemWeight = (EditText) findViewById(R.id.editTextForAddItemWeight);
		editTextForAddItemSku = (EditText) findViewById(R.id.editTextForAddItemSku);
		editTextForAddItemDesc = (EditText) findViewById(R.id.editTextForAddItemDesc);
		editTextForAddItemShortDesc = (EditText) findViewById(R.id.editTextForAddItemShortDesc);
		editTextForAddItemMetaDesc = (EditText) findViewById(R.id.editTextForAddItemMetaDesc);
		btnForScan = (ImageButton) findViewById(R.id.btnForScanBarCode);

		editTextForAddItemWeight
				.setFilters(new InputFilter[] { new DecimalDigitsInputFilter(
						10, 2) });
		backImg.setOnClickListener(this);
		// availableBtn.setOnClickListener(this);
		// FeaturedBtn.setOnClickListener(this);
		btnForAddItem.setOnClickListener(this);
		btnForScan.setOnClickListener(this);
		btnSlideMenu.setVisibility(View.GONE);
		cartBtn.setVisibility(View.GONE);
		backImg.setVisibility(View.VISIBLE);
		textForHeader.setText("ITEM");
		categoryList.add("Beer");
		categoryList.add("Featured");
		categoryList.add("Wine");
		categoryList.add("Liquor");
		categoryList.add("Extras");
		categoryList.add("Select a Category");
		SpinnerAdapter spinAdapter = new SpinnerAdapter(this,
				R.layout.simple_spinner_item, categoryList,"fromAddItem");
		spinnerForCategory.setAdapter(spinAdapter);
		spinnerForCategory.setSelection(categoryList.size() - 1);
		subCategoryList.add("Select a subCategory");
		subCategoryList.add("Select a subCategory");
		subCategoryList.add("Select a subCategory");
		subCategoryList.add("Select a subCategory");
		subCategoryList.add("Select a subCategory");
		subCategoryList.add("Select a subCategory");
		subCategoryIdList.add(" ");
		SpinnerAdapter spinAdapter1 = new SpinnerAdapter(this,
				R.layout.simple_spinner_item, subCategoryList,"fromAddItem");
		spinnerForSubCategory.setAdapter(spinAdapter1);
		spinnerForSubCategory.setSelection(subCategoryList.size() - 1);
		spinnerForSubCategory.getSelectedView();
		spinnerForSubCategory.setEnabled(false);
		spinnerForCategory
				.setOnItemSelectedListener(new OnItemSelectedListener() {

					@Override
					public void onItemSelected(AdapterView<?> parent,
							View view, int position, long id) {
						if (position != categoryList.size() - 1) {
							selectedCategory = categoryList.get(position);

							Log.e("selectedCategory", selectedCategory);
							if (selectedCategory.equals("Beer")) {
								selectedHasmap = Constant.beerhashMapHeader;

							} else if (selectedCategory.equals("Wine")) {
								selectedHasmap = Constant.winehashMapHeader;
							} else if (selectedCategory.equals("Featured")) {
								selectedHasmap = Constant.featuredhashMapHeader;

							} else if (selectedCategory.equals("Liquor")) {
								selectedHasmap = Constant.liquorhashMapHeader;

							} else if (selectedCategory.equals("Extras")) {
								selectedHasmap = Constant.mixerhashMapHeader;

							}
							spinnerForSubCategory.setEnabled(true);
							subCategoryList.clear();
							subCategoryIdList.clear();
							Iterator myVeryOwnIterator = selectedHasmap
									.keySet().iterator();
							while (myVeryOwnIterator.hasNext()) {
								String key = (String) myVeryOwnIterator.next();
								String value = (String) selectedHasmap.get(key);
								Log.e("subcat", "Key: " + key + " Value: "
										+ value);
								subCategoryList.add(key);
								subCategoryIdList.add(value);

							}
							subCategoryList.add("Select a subCategory");
							subCategoryIdList.add(" ");
							SpinnerAdapter spinAdapter = new SpinnerAdapter(
									AddItemActivity.this,
									R.layout.simple_spinner_item,
									subCategoryList,"fromAddItem");
							spinnerForSubCategory.setAdapter(spinAdapter);
							spinnerForSubCategory.setSelection(0);
						}
					}

					@Override
					public void onNothingSelected(AdapterView<?> parent) {
					}

				});

		spinnerForSubCategory
				.setOnItemSelectedListener(new OnItemSelectedListener() {

					@Override
					public void onItemSelected(AdapterView<?> parent,
							View view, int position, long id) {
						if (position != subCategoryList.size() - 1) {
							selectedsubCategory = subCategoryList.get(position);
							selectedsubCategoryId = subCategoryIdList
									.get(position);
							Log.e("selectedsubCategory", selectedsubCategory);
							// Log.e("selectedsubCategoryId",
							// selectedsubCategoryId);
						}

					}

					@Override
					public void onNothingSelected(AdapterView<?> parent) {
					}

				});

		availableBtn.setOnCheckedChangeListener(new OnCheckedChangeListener() {

			@Override
			public void onCheckedChanged(CompoundButton buttonView,
					boolean isChecked) {
				// TODO Auto-generated method stub
				if (availableBtn.isChecked()) {
					itemStatus = 1;
				} else {
					itemStatus = 0;
				}
			}
		});

		editTxtForPrice.addTextChangedListener(new TextWatcher() {

			@Override
			public void onTextChanged(CharSequence s, int start, int before,
					int count) {
				// TODO Auto-generated method stub
				if (!s.toString().equals(current)) {

					try {
						editTxtForPrice.removeTextChangedListener(this);

						String cleanString = s.toString().replaceAll("[$,.]", "");

						double parsed = Double.parseDouble(cleanString);
						String formatted = NumberFormat.getCurrencyInstance()
								.format((parsed / 100));

						current = formatted;
						editTxtForPrice.setText(formatted);
						editTxtForPrice.setSelection(formatted.length());

						editTxtForPrice.addTextChangedListener(this);
					} catch (NumberFormatException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}

			}

			@Override
			public void beforeTextChanged(CharSequence s, int start, int count,
					int after) {
				// TODO Auto-generated method stub

			}

			@Override
			public void afterTextChanged(Editable s) {
			}

		});
	}

	@Override
	public void onClick(View v) {
		// TODO Auto-generated method stub
		if (v.getId() == R.id.backBtn) {
			// finish();
			startActivity(new Intent(AddItemActivity.this,
					TabsFragmentActivity.class));
		}
		// if(v.getId()==R.id.imgsubcatdrop)
		// {
		//
		// }
		// if(v.getId()==R.id.imgcatdrop)
		// {
		//
		// }
		// if(v.getId()==R.id.imageForAvailable){
		// if(available == true){
		// available = false;
		// availableBtn.setImageResource(R.drawable.available_on);
		// }
		// else{
		// available = true;
		// availableBtn.setImageResource(R.drawable.available_off);
		// }
		// }
		//
		// if(v.getId()==R.id.imageForFeatured){
		// if(featured == true){
		// featured = false;
		// FeaturedBtn.setImageResource(R.drawable.available_on);
		// }
		// else{
		// featured = true;
		// FeaturedBtn.setImageResource(R.drawable.available_off);
		// }
		// }

		if (v.getId() == R.id.btnForAddItem) {
			String name = editTxtForName.getText().toString().trim();
			String qty = editTxtForQty.getText().toString().trim();
			String fioz = editTxtForFiOz.getText().toString().trim();
			String price = editTxtForPrice.getText().toString().trim();
			String weight = editTextForAddItemWeight.getText().toString()
					.trim();
			String sku = editTextForAddItemSku.getText().toString().trim();
			String desc = editTextForAddItemDesc.getText().toString().trim();
			String shortdesc = editTextForAddItemShortDesc.toString().trim();
			String metadesc = editTextForAddItemMetaDesc.toString().trim();

			if (name.length() > 0 && qty.length() > 0 && fioz.length() > 0
					&& price.length() > 0 && selectedCategory.length() > 0
					&& selectedsubCategory.length() > 0 && weight.length() > 0
					&& sku.length() > 0 && desc.length() > 0
					&& shortdesc.length() > 0 && metadesc.length() > 0) {
				boolean isOnline = Utils.isOnline();
				Log.e("isOnline", isOnline + "");
				if (isOnline) {
					new AddItem().execute();
				}
				else
				{
					Utils.ShowAlert(AddItemActivity.this, Constant.networkDisconected);
				}
				

			} else {
				Utils.ShowAlert(AddItemActivity.this, "Please fill all fields.");
			}
		}

		if (v.getId() == R.id.btnForScanBarCode) {
			Intent intent = new Intent("com.google.zxing.client.android.SCAN");
			// intent.putExtra("SCAN_MODE", "QR_CODE_MODE");
			intent.putExtra("SCAN_MODE", "CODE_128");

			startActivityForResult(intent, 0);
		}
	}

	public void onActivityResult(int requestCode, int resultCode, Intent intent) {
		if (requestCode == 0) {
			if (resultCode == RESULT_OK) {
				String contents = intent.getStringExtra("SCAN_RESULT");
				// String format = intent.getStringExtra("SCAN_RESULT_FORMAT");
				// Handle successful scan
				// Toast toast = Toast.makeText(this, "Content:" + contents
				// + " Format:" + format, Toast.LENGTH_LONG);
				// toast.setGravity(Gravity.TOP, 25, 400);
				// toast.show();

				editTextForAddItemSku.setText(contents);
			} else if (resultCode == RESULT_CANCELED) {
				// Handle cancel
				Toast toast = Toast.makeText(this, "Scan was Cancelled!",
						Toast.LENGTH_LONG);
				toast.setGravity(Gravity.TOP, 25, 400);
				toast.show();

			}
		}
	}

	public boolean isInstalled(Context myContext, String name) {
		PackageManager myPackageMgr = myContext.getPackageManager();
		try {
			myPackageMgr.getPackageInfo(name, PackageManager.GET_ACTIVITIES);
		} catch (PackageManager.NameNotFoundException e) {
			return (false);
		}
		return (true);
	}

	@SuppressWarnings("unused")
	private boolean appInstalledOrNot(String packagename, Context context) {
		PackageManager pm = context.getPackageManager();
		try {
			pm.getPackageInfo(packagename, PackageManager.GET_ACTIVITIES);
			return true;
		} catch (NameNotFoundException e) {
			return false;
		}
	}

	public class AddItem extends AsyncTask<Void, Void, Void> {
		ProgressDialog dialog;
		String status = "", error, itemQuantity = "";

		@Override
		protected void onPostExecute(Void result) {

			if (dialog.isShowing()) {
				dialog.dismiss();
			}

			try {

				if (status.equals("1")) {

					Utils.ShowAlert(AddItemActivity.this,
							"Item Added Successfully");
					editTxtForName.setText("");
					editTxtForQty.setText("");
					editTxtForFiOz.setText("");
					editTxtForPrice.setText("");
					
					spinnerForCategory.setSelection(0);
					spinnerForSubCategory.setSelection(0);
					editTextForAddItemDesc.setText("");
					editTextForAddItemMetaDesc.setText("");
					editTextForAddItemShortDesc.setText("");
					editTextForAddItemSku.setText("");
					editTextForAddItemWeight.setText("");
				} else {
					Utils.ShowAlert(AddItemActivity.this, error);
				}
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

		}

		@Override
		protected void onPreExecute() {
			super.onPreExecute();
			this.dialog = new ProgressDialog(AddItemActivity.this);
			this.dialog.setMessage("Loading..");
			this.dialog.show();
			this.dialog.setCancelable(false);

		}

		@Override
		protected Void doInBackground(Void... params) {

			List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>(6);

			Log.e("selectedsubCategoryId", selectedsubCategoryId);
			nameValuePair.add(new BasicNameValuePair("category_id",
					selectedsubCategoryId));
			nameValuePair.add(new BasicNameValuePair("product_name",
					editTxtForName.getText().toString().trim()));
			nameValuePair.add(new BasicNameValuePair("product_sku",
					editTextForAddItemSku.getText().toString().trim()));
			nameValuePair.add(new BasicNameValuePair("product_description",
					editTextForAddItemDesc.getText().toString().trim()));
			nameValuePair.add(new BasicNameValuePair(
					"product_short_description", editTextForAddItemShortDesc
							.getText().toString().trim()));
			nameValuePair.add(new BasicNameValuePair("product_weight",
					editTextForAddItemWeight.getText().toString().trim()));
			String price = editTxtForPrice.getText().toString().trim()
					.replace("$", "");
			nameValuePair.add(new BasicNameValuePair("product_price", price));
			nameValuePair.add(new BasicNameValuePair("product_qty",
					editTxtForQty.getText().toString()));
			nameValuePair.add(new BasicNameValuePair(
					"product_meta_description", editTextForAddItemMetaDesc
							.getText().toString().trim()));
			nameValuePair.add(new BasicNameValuePair("product_stock", Integer
					.toString(itemStatus)));

			JSONObject jsonObj = new ServerResponse(
					UrlGenerator.vendorAddItem()).getJSONObjectfromURL(
					RequestType.POST, nameValuePair);

			try {
				if (jsonObj != null) {
					status = jsonObj.getString("status");
					if (status.equals("0")) {
						error = jsonObj.getString("Error");
					} else if (status.equals("1")) {

					}
				}
			} catch (JSONException e) {
				e.printStackTrace();
			}
			return null;
		}
	}

	public class DecimalDigitsInputFilter implements InputFilter {

		Pattern mPattern;

		public DecimalDigitsInputFilter(int digitsBeforeZero,
				int digitsAfterZero) {
			mPattern = Pattern.compile("[0-9]{0," + (digitsBeforeZero - 1)
					+ "}+((\\.[0-9]{0," + (digitsAfterZero - 1)
					+ "})?)||(\\.)?");
		}

		@Override
		public CharSequence filter(CharSequence source, int start, int end,
				Spanned dest, int dstart, int dend) {
			// TODO Auto-generated method stub
			Matcher matcher = mPattern.matcher(dest);
			if (!matcher.matches())
				return "";
			return null;
		}

	}

	class CurrencyTextWatcher implements TextWatcher {

		boolean mEditing;

		public CurrencyTextWatcher() {
			mEditing = false;
		}

		public synchronized void afterTextChanged(Editable s) {
			if (!mEditing) {
				mEditing = true;

				String digits = s.toString().replaceAll("\\D", "");
				NumberFormat nf = NumberFormat.getCurrencyInstance();
				try {
					String formatted = nf
							.format(Double.parseDouble(digits) / 100);
					s.replace(0, s.length(), formatted);
				} catch (NumberFormatException nfe) {
					s.clear();
				}

				mEditing = false;
			}
		}

		public void beforeTextChanged(CharSequence s, int start, int count,
				int after) {
		}

		public void onTextChanged(CharSequence s, int start, int before,
				int count) {
		}

	}

}
